#include "system.h"
#include "altera_avalon_timer_regs.h"
#include "altera_avalon_pio_regs.h"
#include "alt_types.h"
#include "sys/alt_irq.h"
#include <stdio.h>

// Variables globales
volatile int seconds = 0;
volatile int minutes = 0;
volatile int hours = 0;
volatile int timer_interrupt = 0;

// Patrones para los números 0-9 para un display de ánodo común
static const uint8_t patterns[10] = {
    0x3F, // 0
    0x06, // 1
    0x5B, // 2
    0x4F, // 3
    0x66, // 4
    0x6D, // 5
    0x7D, // 6
    0x07, // 7
    0x7F, // 8
    0x6F  // 9
};

// Función para mostrar un número en un display de 7 segmentos
void display_digit_on_segment(int segment, int digit) {
    IOWR_ALTERA_AVALON_PIO_DATA(segment, patterns[digit]);
}

// Actualiza los displays con la hora actual
void update_displays() {
    // Mostrar horas
    display_digit_on_segment(SSEG_HOUR_TENS_BASE, hours / 10);  // Decenas de horas
    display_digit_on_segment(SSEG_HOUR_UNITS_BASE, hours % 10); // Unidades de horas

    // Mostrar minutos
    display_digit_on_segment(SSEG_MINS_TENS_BASE, minutes / 10);  // Decenas de minutos
    display_digit_on_segment(SSEG_MIN_UNITS_BASE, minutes % 10); // Unidades de minutos

    // Mostrar segundos
    display_digit_on_segment(SSEG_SEC_TENS_BASE, seconds / 10);  // Decenas de segundos
    display_digit_on_segment(SSEG_SEC_UNITS_BASE, seconds % 10); // Unidades de segundos
}

// Manejador de interrupciones del Timer
static void timer_isr(void* context, alt_u32 id) {
    // Leer el estado del Timer para saber si ocurrió la interrupción por timeout
    alt_u32 status = IORD_ALTERA_AVALON_TIMER_STATUS(TIMER_BASE);

    if (status & ALTERA_AVALON_TIMER_STATUS_TO_MSK) {
        // Limpiar la bandera de interrupción
        IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_BASE, 0);

        // Incrementar los segundos y manejar el overflow
        seconds++;
        if (seconds >= 60) {
            seconds = 0;
            minutes++;
            if (minutes >= 60) {
                minutes = 0;
                hours++;
                if (hours >= 24) {
                    hours = 0;
                }
            }
        }

        // Actualizar los displays
        update_displays();
    }
}

int main() {
    // Configurar el Timer para generar interrupciones cada segundo
    IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER_BASE, 0x4240);  // Parte baja del periodo (0x4240 = 50000)
    IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_BASE, 0x0000);  // Parte alta del periodo (para un clock de 50 MHz)
    IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK);

    // Registrar la ISR del Timer
    alt_irq_register(TIMER_IRQ, NULL, timer_isr);

    // Inicializar los displays con el tiempo inicial
    update_displays();

    while (1) {
        // El reloj se actualiza automáticamente mediante la ISR del Timer
    }

    return 0;
}
